<!doctype html><html lang=zh><head><meta name=viewport content="width=device-width,initial-scale=1"><title>Go的sync.RWMutex</title><meta charset=utf-8><meta name=description content="Ladder@为什么需要锁？（锁就像一把钥匙，只有一个协程得到并打开共享资源的门） 解决并发访问共享资源时，出现的数据竞争和并发异常问题 如何设计和实现 首先定"><meta name=author content="ErnestChen"><link rel=canonical href=https://hi-ernest.github.io/blog/go-knowledge-points/><meta name=google-site-verification content="xxx"><link rel=alternate type=application/rss+xml href=https://hi-ernest.github.io//index.xml title="Always Exploring"><script async defer data-website-id=f3deb06c-5a53-49a7-a8e1-b4ce23c412ba src=https://umami-blog-analyze-30k29jpw4-hi-ernest.vercel.app/hugo-ladder></script><meta property="og:title" content="Go的sync.RWMutex"><meta property="og:description" content="为什么需要锁？（锁就像一把钥匙，只有一个协程得到并打开共享资源的门） 解决并发访问共享资源时，出现的数据竞争和并发异常问题 如何设计和实现 首先定"><meta property="og:type" content="article"><meta property="og:url" content="https://hi-ernest.github.io/blog/go-knowledge-points/"><meta property="article:section" content="blog"><meta property="article:published_time" content="2023-06-29T16:05:37+08:00"><meta property="article:modified_time" content="2023-06-29T16:05:37+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Go的sync.RWMutex"><meta name=twitter:description content="为什么需要锁？（锁就像一把钥匙，只有一个协程得到并打开共享资源的门） 解决并发访问共享资源时，出现的数据竞争和并发异常问题 如何设计和实现 首先定"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Blogs","item":"https://hi-ernest.github.io/blog/"},{"@type":"ListItem","position":2,"name":"Go的sync.RWMutex","item":"https://hi-ernest.github.io/blog/go-knowledge-points/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Go的sync.RWMutex","name":"Go的sync.RWMutex","description":"为什么需要锁？（锁就像一把钥匙，只有一个协程得到并打开共享资源的门） 解决并发访问共享资源时，出现的数据竞争和并发异常问题 如何设计和实现 首先定","keywords":["go"],"articleBody":"为什么需要锁？（锁就像一把钥匙，只有一个协程得到并打开共享资源的门）\n解决并发访问共享资源时，出现的数据竞争和并发异常问题\n如何设计和实现 首先定义结构体，需要\n字段state int32类型来表示锁状态（0代表锁未持有，1代表锁已经被某个协程持有），使用atomic的cas来更新state字段，标记是否获取锁 需要等待队列queue存放阻塞goroutine（先入先出）,依次被唤醒，唤醒后g需要争抢获取锁； 唤醒和挂起都需要cpu开销，可以插入队列前先自旋抢锁，得到更高的吞吐量，但不能一直自旋，也需要记录自旋次数字段spin 信号量字段来唤醒等待的goroutine获取锁 进一步优化，释放锁后新创建g1和唤醒队首的g2争抢锁，往往新创建g1会获取锁，因为新创建在cpu运行+数量比较多 可能导致队列中g一直获取不到锁，造成尾部延时；增加互斥锁状态模式字段，表示正常/饥饿状态，如果一个等待goroutine超过1ms还没有获取锁切换到饥饿状态，互斥锁解锁后优先让队首g获取，新创建g直接插入队尾。如果g是队列最后一个元素or等待时间小于1ms会从饥饿状态切换正常状态。 type RWMutex struct { w Mutex // 一个互斥锁的字段，用户进行写时加互斥锁 writerSem uint32 // 一个writer的信号量，类似互斥锁中的信号量 readerSem uint32 // 一个reader的信号量，类似互斥锁中的信号量 readerCount int32 // 两种作用，1:标记有多少拿到读锁的reader，2:是否有writer需要竞争 readerWait int32 // writer需要等待读锁解锁的reader的数量 } const rwmutexMaxReaders = 1 \u003c\u003c 30 // 最大reader的上限。即最多有多少的reader同时能拿到读锁 读锁加锁：针对readerCount字段的判断，如果其+1仍未负数时就代表此时此刻写锁已经被获取，即需要进行阻塞等待写锁的解锁 读锁的解锁：判断是否有正在等待的写锁，如果没有就直接返回，否则就进行readerWait字段的校验判断是否是最后一个需要等待的读锁后唤醒，等待读锁释放完的writer进行写锁的获取。 写锁的加锁过程必须先对整体的结构体的Mutex进行加锁，以免有其他的写操作同时对写锁的竞争导致data race。然后进行当前持有读锁的reader的数量进行取反，并且将其值交给readerWait 用于标记需要等待释放锁的reader的数量，如果该字段不等于0则代表需要进行读锁解锁等待。当reader调用RUlock时会进行对此字段的-1并且判断，如果此字段为0时，则唤醒writer的阻塞，使得writer获取到写锁。 写锁的解锁方式很简单，先进行readerCount的取反，以便告知无writer正在竞争，然后依次去唤醒这些等待的reader去获取读锁，然后将互斥锁写锁，以便后续的writer进行写操作，在写操作时，加锁时先进行互斥锁的加锁，解锁时后进行互斥锁的解锁，为的是保证字段的修改也受到互斥锁的保护。 go的读写锁采用的是Write-preferring（即写优先）的设计，这样可以保证写操作在大量的读操作进行时不会被饿死。但是相对于Read-preferring（即读优先）的设计会降低读的并发性，但是这种方式避免了写会出现饥饿问题。也是一种良好的解决办法 ","wordCount":"1305","inLanguage":"zh","datePublished":"2023-06-29T16:05:37+08:00","dateModified":"2023-06-29T16:05:37+08:00","author":{"@type":"Person","name":"ErnestChen"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://hi-ernest.github.io/blog/go-knowledge-points/"},"publisher":{"@type":"Organization","name":"Always Exploring","logo":{"@type":"ImageObject","url":"https://hi-ernest.github.io/favicon.ico"}}}</script><link rel=icon href=/images/avatar.png sizes=16x16><link rel=apple-touch-icon href=/images/avatar.png><link rel=manifest href=/images/avatar.png><link rel=stylesheet href=https://cdn.staticfile.org/lxgw-wenkai-webfont/1.6.0/style.css><link rel=stylesheet href=/css/main.min.293f0784fbb6eb386b8e8a866f94b8300116a74d7936c439e847ca3aa358a5d9.css integrity="sha256-KT8HhPu26zhrjoqGb5S4MAEWp015NsQ56EfKOqNYpdk=" crossorigin=anonymous media=screen><link rel=stylesheet href=/scss/highlight/github-dark.min.min.66034289ee9a113219a2c4aae0a8bd2095ab255c832a42efcf5863f10814e7a1.css><script src=/js/highlight.min.min.872dfd2cd00064018a833a6e8e77a0fbf8fbac159546f2f205d4dad79a5d8e15.js></script>
<script>hljs.highlightAll()</script><script>(()=>{var t=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches,e=localStorage.getItem("theme");t&&e===null&&(localStorage.setItem("theme","dark"),document.documentElement.setAttribute("data-dark-mode","")),t&&e==="dark"&&document.documentElement.setAttribute("data-dark-mode",""),e==="dark"&&document.documentElement.setAttribute("data-dark-mode","")})()</script></head><body><main class=wrapper><nav class=navigation><section class=container><a class=navigation-brand href=/>HOME</a>
<input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><span></span><span></span><span></span></label><ul class=navigation-list id=navigation-list><li class="navigation-item navigation-menu"><a class=navigation-link href=/blog>文章</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=/archives>历史</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=/guestbook>留言板</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=https://umami-blog-analyze-30k29jpw4-hi-ernest.vercel.app/share/F0HNiV8DX3mdMGa3/hi-Ernest>统计</a></li><li class="navigation-item menu-separator"><span>|</span></li><li class="navigation-item navigation-social"><a class=navigation-link href=https://github.com/hi-Ernest/resume/blob/master/resume-zh.pdf><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a></li><li class="navigation-item navigation-dark"><button id=mode type=button aria-label="toggle user light or dark theme">
<span class=toggle-dark><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-moon"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg></span><span class=toggle-light><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-sun"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></span></button></li></ul></section></nav><div id=content><article class=blog-single><header class=blog-title><h1>Go的sync.RWMutex</h1></header><p><small>2023年6月29日&nbsp;· 1305 字&nbsp;· 3 分钟</small>
<small>·
<a href=https://hi-ernest.github.io/tags/go/>go</a></small><p><div class=blog-toc><nav id=TableOfContents><ul><li><ul><li><a href=#如何设计和实现>如何设计和实现</a></li></ul></li></ul></nav></div><section class=blog-content><p>为什么需要锁？（锁就像一把钥匙，只有一个协程得到并打开共享资源的门）</p><blockquote><p>解决并发访问共享资源时，出现的数据竞争和并发异常问题</p></blockquote><h3 id=如何设计和实现>如何设计和实现</h3><p>首先定义结构体，需要</p><ol><li>字段state int32类型来表示锁状态（0代表锁未持有，1代表锁已经被某个协程持有），使用atomic的cas来更新state字段，标记是否获取锁</li><li>需要等待队列queue存放阻塞goroutine（先入先出）,依次被唤醒，唤醒后g需要争抢获取锁；</li><li>唤醒和挂起都需要cpu开销，可以插入队列前先自旋抢锁，得到更高的吞吐量，但不能一直自旋，也需要记录自旋次数字段spin</li><li>信号量字段来唤醒等待的goroutine获取锁</li><li>进一步优化，释放锁后新创建g1和唤醒队首的g2争抢锁，往往新创建g1会获取锁，因为新创建在cpu运行+数量比较多
可能导致队列中g一直获取不到锁，造成尾部延时；增加互斥锁状态模式字段，表示正常/饥饿状态，如果一个等待goroutine超过1ms还没有获取锁切换到饥饿状态，互斥锁解锁后优先让队首g获取，新创建g直接插入队尾。如果g是队列最后一个元素or等待时间小于1ms会从饥饿状态切换正常状态。</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>RWMutex</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>w</span>           <span style=color:#a6e22e>Mutex</span>  <span style=color:#75715e>// 一个互斥锁的字段，用户进行写时加互斥锁
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>writerSem</span>   <span style=color:#66d9ef>uint32</span> <span style=color:#75715e>// 一个writer的信号量，类似互斥锁中的信号量
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>readerSem</span>   <span style=color:#66d9ef>uint32</span> <span style=color:#75715e>// 一个reader的信号量，类似互斥锁中的信号量
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>readerCount</span> <span style=color:#66d9ef>int32</span>  <span style=color:#75715e>// 两种作用，1:标记有多少拿到读锁的reader，2:是否有writer需要竞争
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>readerWait</span>  <span style=color:#66d9ef>int32</span>  <span style=color:#75715e>// writer需要等待读锁解锁的reader的数量
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>rwmutexMaxReaders</span> = <span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>30</span> <span style=color:#75715e>// 最大reader的上限。即最多有多少的reader同时能拿到读锁
</span></span></span></code></pre></div><ul><li>读锁加锁：针对readerCount字段的判断，如果其+1仍未负数时就代表此时此刻写锁已经被获取，即需要进行阻塞等待写锁的解锁</li><li>读锁的解锁：判断是否有正在等待的写锁，如果没有就直接返回，否则就进行readerWait字段的校验判断是否是最后一个需要等待的读锁后唤醒，等待读锁释放完的writer进行写锁的获取。</li><li>写锁的加锁过程必须先对整体的结构体的Mutex进行加锁，以免有其他的写操作同时对写锁的竞争导致data race。然后进行当前持有读锁的reader的数量进行取反，并且将其值交给readerWait</li><li>用于标记需要等待释放锁的reader的数量，如果该字段不等于0则代表需要进行读锁解锁等待。当reader调用RUlock时会进行对此字段的-1并且判断，如果此字段为0时，则唤醒writer的阻塞，使得writer获取到写锁。</li><li>写锁的解锁方式很简单，先进行readerCount的取反，以便告知无writer正在竞争，然后依次去唤醒这些等待的reader去获取读锁，然后将互斥锁写锁，以便后续的writer进行写操作，在写操作时，加锁时先进行互斥锁的加锁，解锁时后进行互斥锁的解锁，为的是保证字段的修改也受到互斥锁的保护。</li><li>go的读写锁采用的是Write-preferring（即写优先）的设计，这样可以保证写操作在大量的读操作进行时不会被饿死。但是相对于Read-preferring（即读优先）的设计会降低读的并发性，但是这种方式避免了写会出现饥饿问题。也是一种良好的解决办法</li></ul></section><div class=paginator><a class=prev href=https://hi-ernest.github.io/blog/warehouse-clould/><svg class="icon" width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M3.77086 21.1546C11.0491 22.698 21.4339 21.7773 21.4339 16.3608V4.63375c0-.69413-.075800000000001-1.3284-.2422-1.86588M3.77086 21.1546C1.9934 20.7777.973585 18.7264 1.08749 16.688c.17931-3.209.06972-7.25665-.08236-10.47293C.87809 3.52811 3.12891 1.16316 5.51029 1.25008c4.25565.15534 9.86671-.04779 13.28091-.24466 1.2952-.074686 2.0494.62843 2.4005 1.76245M3.77086 21.1546C4.56586 21.4723 5.49168 21.7879 6.5 22.0658M21.1917 2.76787c1.918 1.4143 1.9383 9.65123 1.7087 13.59293-2.0526 7.6586-10.5943 7.3054-16.4004 5.705M21.1917 2.76787C21.7612 4.51192 22.7203 9.67216 22 16.3608 21.2797 23.0494 11.3665 22.9511 6.5 22.0658M9.94496 9C9.28897 9.61644 7.63215 10.997 6.04814 11.7966 5.98257 11.8297 5.98456 11.9753 6.05061 12.0063c1.00435.4716 2.8788 1.9201 3.89435 2.9937M6.44444 11.9667C8.86549 12.0608 14 12 16 11" stroke="currentcolor" stroke-linecap="round"/></svg><span>云仓inbound面试准备</span></a>
<a class=next href=https://hi-ernest.github.io/blog/23-05-20-think/><span>母亲的话&自己思考</span><svg class="icon" width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M3.77086 21.1546C11.0491 22.698 21.4339 21.7773 21.4339 16.3608V4.63375c0-.69413-.075800000000001-1.3284-.2422-1.86588M3.77086 21.1546C1.9934 20.7777.973585 18.7264 1.08749 16.688c.17931-3.209.06972-7.25665-.08236-10.47293C.87809 3.52811 3.12891 1.16316 5.51029 1.25008c4.25565.15534 9.86671-.04779 13.28091-.24466 1.2952-.074686 2.0494.62843 2.4005 1.76245M3.77086 21.1546C4.56586 21.4723 5.49168 21.7879 6.5 22.0658M21.1917 2.76787c1.918 1.4143 1.9383 9.65123 1.7087 13.59293-2.0526 7.6586-10.5943 7.3054-16.4004 5.705M21.1917 2.76787C21.7612 4.51192 22.7203 9.67216 22 16.3608 21.2797 23.0494 11.3665 22.9511 6.5 22.0658M12.055 9C12.711 9.61644 14.3679 10.997 15.9519 11.7966 16.0174 11.8297 16.0154 11.9753 15.9494 12.0063 14.945 12.4779 13.0706 13.9264 12.055 15m3.5006-3.0333C13.1345 12.0608 8 12 6 11" stroke="currentcolor" stroke-linecap="round"/></svg></a></div><div class=comments><script>const getTheme=window.localStorage&&window.localStorage.getItem("theme");let theme=getTheme==="dark"?"dark":"light",s=document.createElement("script");s.src="https://giscus.app/client.js",s.setAttribute("data-repo","hi-Ernest/blog-comments"),s.setAttribute("data-repo-id","R_kgDOKfq-Xw"),s.setAttribute("data-category","Announcements"),s.setAttribute("data-category-id","DIC_kwDOKfq-X84CaFwF"),s.setAttribute("data-mapping","pathname"),s.setAttribute("data-strict","0"),s.setAttribute("data-reactions-enabled","1"),s.setAttribute("data-emit-metadata","0"),s.setAttribute("data-input-position","top"),s.setAttribute("data-theme",theme),s.setAttribute("data-lang","zh-CN"),s.setAttribute("data-loading","lazy"),s.setAttribute("crossorigin","anonymous"),s.setAttribute("async",""),document.querySelector("div.comments").innerHTML="",document.querySelector("div.comments").appendChild(s)</script></div></article></div><footer class=footer><p>&copy; 2023 <a href=https://hi-ernest.github.io/>Always Exploring</a>
Powered by
<a href=https://gohugo.io/ rel=noopener target=_blank>Hugo️️</a>
<a href=https://github.com/guangzhengli/hugo-theme-ladder rel=noopener target=_blank>Ladder</a>
️</p></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M10.5376 22.7916C11.0152 22.7207 22.5795 21.1781 22.0978 10.4211 22.0536 9.43274 21.9303 8.53367 21.7387 7.71865M10.5376 22.7916C16.876 22.3728 20.0969 19.8899 21.5383 16.9142M10.5376 22.7916C9.7707 22.9055 8.97982 22.8964 8.19743 22.7725M21.7387 7.71865C21.4988 6.69828 21.1518 5.80967 20.7188 5.04257m1.0199 2.67608C22.6022 10.1105 23.0542 13.7848 21.5383 16.9142M20.7188 5.04257c-3.5504-6.28886-12.88753-4.410077-16.44303.0C2.88063 6.77451-.0433281 11.1668 1.38159 16.6571c.89322 3.4417 3.7911 5.6365 6.81584 6.1154M20.7188 5.04257c1.3509 1.89783 3.3111 6.34223 1.6353 10.37273M21.5383 16.9142C21.8737 16.4251 22.1428 15.9235 22.3541 15.4153M8.19743 22.7725C12.1971 23.4683 20.6281 22.971 22.3541 15.4153M14 10.945C13.3836 10.289 12.003 8.63215 11.2034 7.04814 11.1703 6.98257 11.0247 6.98456 10.9937 7.05061 10.5221 8.05496 9.07362 9.92941 8 10.945m3.0333-3.50056C10.9392 9.86549 11 15 12 17" stroke="currentcolor" stroke-linecap="round"/></svg></a><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const s=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="Copy";function n(){t.innerHTML="Copied",setTimeout(()=>{t.innerHTML="Copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),n();return}const s=document.createRange();s.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(s);try{document.execCommand("copy"),n()}catch{}o.removeRange(s)}),e.parentNode.appendChild(t)})</script></main></body><script src=https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.0.6/medium-zoom.min.js integrity="sha512-N9IJRoc3LaP3NDoiGkcPa4gG94kapGpaA5Zq9/Dr04uf5TbLFU5q0o8AbRhLKUUlp8QFS2u7S+Yti0U7QtuZvQ==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script>const images=Array.from(document.querySelectorAll(".blog-content img"));images.forEach(e=>{mediumZoom(e,{margin:10,scrollOffset:40,container:null,template:null,background:"rgba(0, 0, 0, 0.5)"})})</script><script src=/main.min.6bb26b69159420159c74dc9e097b06a578ed2b68c701466a91a44a9632d851bd0af167a1b30012387b4c512b48ad9ad4d3394e04d77ae38d57e1920fe4ed34fe.js integrity="sha512-a7JraRWUIBWcdNyeCXsGpXjtK2jHAUZqkaRKljLYUb0K8WehswASOHtMUStIrZrU0zlOBNd6441X4ZIP5O00/g==" crossorigin=anonymous defer></script></html>