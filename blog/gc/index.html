<!doctype html><html lang=zh><head><meta name=viewport content="width=device-width,initial-scale=1"><title>垃圾回收GC</title><meta charset=utf-8><meta name=description content="Ladder@什么是GC GC指一种自动的存储器管理机制，当某个程序占用的一部分内存空间不再被这个程序访问时，这个程序会借助垃圾回收算法向操作系统归还这部分"><meta name=author content="ErnestChen"><link rel=canonical href=https://hi-ernest.github.io/blog/gc/><meta name=google-site-verification content="xxx"><link rel=alternate type=application/rss+xml href=https://hi-ernest.github.io//index.xml title="Always Exploring"><script async defer data-website-id=f3deb06c-5a53-49a7-a8e1-b4ce23c412ba src=https://umami-blog-analyze-30k29jpw4-hi-ernest.vercel.app/hugo-ladder></script><meta property="og:title" content="垃圾回收GC"><meta property="og:description" content="什么是GC GC指一种自动的存储器管理机制，当某个程序占用的一部分内存空间不再被这个程序访问时，这个程序会借助垃圾回收算法向操作系统归还这部分"><meta property="og:type" content="article"><meta property="og:url" content="https://hi-ernest.github.io/blog/gc/"><meta property="article:section" content="blog"><meta property="article:published_time" content="2021-12-13T01:21:40+08:00"><meta property="article:modified_time" content="2021-12-13T01:21:40+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="垃圾回收GC"><meta name=twitter:description content="什么是GC GC指一种自动的存储器管理机制，当某个程序占用的一部分内存空间不再被这个程序访问时，这个程序会借助垃圾回收算法向操作系统归还这部分"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Blogs","item":"https://hi-ernest.github.io/blog/"},{"@type":"ListItem","position":2,"name":"垃圾回收GC","item":"https://hi-ernest.github.io/blog/gc/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"垃圾回收GC","name":"垃圾回收GC","description":"什么是GC GC指一种自动的存储器管理机制，当某个程序占用的一部分内存空间不再被这个程序访问时，这个程序会借助垃圾回收算法向操作系统归还这部分","keywords":["java"],"articleBody":"什么是GC GC指一种自动的存储器管理机制，当某个程序占用的一部分内存空间不再被这个程序访问时，这个程序会借助垃圾回收算法向操作系统归还这部分内存空间。垃圾回收器可以减轻程序员的负担，也减少程序中的错误。\n-from wiki\n垃圾回收算法有哪些 分别的优缺点 ================\n引用计数法 对每个对象设置引用计数，当对象被引用+1，失去引用/销毁-1，当计数为0的时回收对象内存\n优点：简单直接，回收速度快\n缺点：需要额外空间维护引用计数，无法解决对象的循环引用问题\n标记清除法 从根对象开始遍历所有引用对象，引用的对象打上标记tag，遍历完成，将没有标记的进行回收\n优点：解决引用计数法的缺点\n缺点：会产生大量不连续的内存碎片，导致无法给大对象分配内存\n标记整理法 让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存\n优点：不会产生内存碎片\n缺点：需要移动大量对象，处理效率比较低。\n#复制 –\n将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理\n优点：不会产生内存碎片，每次清除针对的都是整块内存\n缺点：只使用了内存的一半、移动对象需要耗费时间，效率低于标记清除法\n分代收集法 按照对象的生命周期长短划分代空间，生命周期长的放在老年代，生命周期短的放在新生代\n优点：回收性能好\n缺点：算法复杂\ngo的垃圾回收采用是哪个GC方法 ================\ngo采用的是标记清除法，核心就是标记出哪些是内存还在使用（被引用的），哪些内存不再使用（未被引用），把未被引用的内存回收掉，供后续内存分配使用。\n暂时无法在飞书文档外展示此内容\n特殊case：如果内存块存放的是指针，那还需要递归的进行标记，全部标记完后，只保留标记的内存，未被标记的内存全部进行回收\n为什么Go采用标记清除法，而不是其他的方法？ ======================\n引用计数无法解决循环引用，排除\n标记整理好处在于解决内存碎片化的问题，但是Go运行时的分配算法基于tcmalloc，基本上没有碎片问题，对于gc并没有提升\n复制只能用一半的内存，还需要大量移动，效率低\n分代收集的话也不适用，因为go的gc主要目标是新创建的对象上，即存活时间短更利回收，而不是频繁的检查所有对象\n逃逸分析：编译器决定内存分配的位置，不需要程序员指定。函数中申请一个新的对象\n如果分配到栈，则函数执行结束就可自动将内存回收\n如果分配到堆，则函数执行结束可交给GC(垃圾回收)处理\ngo编译器的逃逸分析，将大部分新生对象存储在栈里面，直接被回收，生命周期短的对象直接回收并不需要gc处理，长期存在的/比较大的对象会分配到堆中，才被gc回收，所以分代回收并没有实质上提升\n什么是三色标记法？mark-sweep ===================\n人为的用三种颜色好描述go的gc过程，内存中的对象并无颜色区分\n三色对应了垃圾回收中的三种状态：\n灰色：对象放入“标记队列”中等待（待处理的对象）\n黑色：对象已被标记为使用\n白色：对象未被标记\n步骤：\n开始gc初，所有对象放入白色队列\n从根对象开始遍历，将所有可达的对象，标记为灰色，放入灰色队列（待处理队列）\n从灰色队列中取出灰色对象，将它引用的对象标记灰色放入灰色队列，它自己标黑色，放入黑色队列\n重复步骤3，直到灰色队列为空，这时候白色对象是不可达对象，回收白色对象\n什么是根对象，根对象有哪些？ ==============\n全局变量：程序在编译期就能确定的那些存在于程序整个生命周期的变量\n执行栈：每个 goroutine 都包含自己的执行栈，这些执行栈上包含栈上的变量及指向分配的堆内存区块的指针\n寄存器：寄存器的值可能表示一个指针，参与计算的这些指针可能指向某些赋值器分配的堆内存区块\n怎么的条件会触发Go的GC =============\nGOGC threshold 每次内存分配时检查当前内存分配量是否达到阀值，达到则会触发gc\n阀值 = 上次gc内存分配量 * 内存增长率\n内存增长率是由环境变量GCGO控制，默认是100，即当内存扩大一倍的时候启动gc\nruntime.GC() 类似Java的system.gc api手动代码触发gc\nruntime.forcegcperiod（2min） 强制定期gc，默认2min触发一次gc，在runtime/proc.go:forcegcperiod\ngo的GC有哪些优化 ==========\n标记-清理需要stw，需要暂停所有的goruntine，做gc然后再恢复。\n减少stw时间，可以提升go的gc性能\n写屏障(Write Barrier) 本质就是每次内存写操作时候，额外执行一小段代码\n写屏障就是让goroutine与GC同时运行的手段，虽然写屏障不能完全消除stw，但是可以大大减少stw时间，类似开关，gc的特定时候开启，开启后指针传递时，把指针标记，即本轮不回收，下次gc再确定\n辅助GC(Mutator Assist) 为了防止内存分配过快，在GC执行过程中，如果goroutine需要分配内存，那么这个goroutine会参与一部分GC的 工作，即帮助GC做一部分工作，这个机制叫作Mutator Assist\n代码GC编程 多制造inline的机会，将新对象尽可能都分配到栈而不是堆，因为go实现了退栈即释放，不影响gc\n代码减少逃逸分析： 尽量使用局部变量（编译器会根据变量是否被外部引用来决定是否逃逸）\n参数、返回数值传递值（传指针还是数值，需要修改原值或者内存比较大结构体传指针，而对于只读的占内存较少的结构体，传值获取较好性能）\n代码简单直白，制造inline机会 减少分配次数 a = make([]int, 0, 1234) b = make(map[string]int, 2048) 缓存对象 什么是inline 内联扩展或内联是一种手动或编译器优化，它用被调用函数的主体替换函数调用站点\nfrom wiki\n通过参数-gflags=\"-m\"查看\nfunc add (x, y int) { return x + y } func main() { x := 1 y := 2 a := add(x,y) fmt.println(a) } \\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\-\\- func main() { x := 1 y := 2 //inline function add replace by the body of the function a := x + y fmt.println(a) } 不用使用内联的case：闭包调用、select、for、defer、go关键词创建的协程\n总结：采用越简单的实现，对于傻瓜式语言性能越好\n逃逸分析 通过命令go build -gcflags ‘-m’命令查看\nvar refs = make([]*int, 32) func fc() { refs[0] = new(int) } func main() { fc() } ","wordCount":"2408","inLanguage":"zh","datePublished":"2021-12-13T01:21:40+08:00","dateModified":"2021-12-13T01:21:40+08:00","author":{"@type":"Person","name":"ErnestChen"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://hi-ernest.github.io/blog/gc/"},"publisher":{"@type":"Organization","name":"Always Exploring","logo":{"@type":"ImageObject","url":"https://hi-ernest.github.io/favicon.ico"}}}</script><link rel=icon href=/images/avatar.png sizes=16x16><link rel=apple-touch-icon href=/images/avatar.png><link rel=manifest href=/images/avatar.png><link rel=stylesheet href=https://cdn.staticfile.org/lxgw-wenkai-webfont/1.6.0/style.css><link rel=stylesheet href=/css/main.min.293f0784fbb6eb386b8e8a866f94b8300116a74d7936c439e847ca3aa358a5d9.css integrity="sha256-KT8HhPu26zhrjoqGb5S4MAEWp015NsQ56EfKOqNYpdk=" crossorigin=anonymous media=screen><link rel=stylesheet href=/scss/highlight/github-dark.min.min.66034289ee9a113219a2c4aae0a8bd2095ab255c832a42efcf5863f10814e7a1.css><script src=/js/highlight.min.min.872dfd2cd00064018a833a6e8e77a0fbf8fbac159546f2f205d4dad79a5d8e15.js></script>
<script>hljs.highlightAll()</script><script>(()=>{var t=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches,e=localStorage.getItem("theme");t&&e===null&&(localStorage.setItem("theme","dark"),document.documentElement.setAttribute("data-dark-mode","")),t&&e==="dark"&&document.documentElement.setAttribute("data-dark-mode",""),e==="dark"&&document.documentElement.setAttribute("data-dark-mode","")})()</script></head><body><main class=wrapper><nav class=navigation><section class=container><a class=navigation-brand href=/>HOME</a>
<input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><span></span><span></span><span></span></label><ul class=navigation-list id=navigation-list><li class="navigation-item navigation-menu"><a class=navigation-link href=/blog>文章</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=/archives>历史</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=/guestbook>留言板</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=https://umami-blog-analyze-30k29jpw4-hi-ernest.vercel.app/share/F0HNiV8DX3mdMGa3/hi-Ernest>统计</a></li><li class="navigation-item menu-separator"><span>|</span></li><li class="navigation-item navigation-social"><a class=navigation-link href=https://github.com/hi-Ernest/resume/blob/master/resume-zh.pdf><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a></li><li class="navigation-item navigation-dark"><button id=mode type=button aria-label="toggle user light or dark theme">
<span class=toggle-dark><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-moon"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg></span><span class=toggle-light><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-sun"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></span></button></li></ul></section></nav><div id=content><article class=blog-single><header class=blog-title><h1>垃圾回收GC</h1></header><p><small>2021年12月13日&nbsp;· 2408 字&nbsp;· 5 分钟</small>
<small>·
<a href=https://hi-ernest.github.io/tags/java/>java</a></small><p><div class=blog-toc><nav id=TableOfContents><ul><li><a href=#什么是gc>什么是GC</a></li><li><a href=#垃圾回收算法有哪些-分别的优缺点>垃圾回收算法有哪些 分别的优缺点</a></li><li><a href=#引用计数法>引用计数法</a></li><li><a href=#标记清除法>标记清除法</a></li><li><a href=#标记整理法>标记整理法</a></li><li><a href=#复制>#复制</a></li><li><a href=#分代收集法>分代收集法</a></li><li><a href=#go的垃圾回收采用是哪个gc方法>go的垃圾回收采用是哪个GC方法</a></li><li><a href=#为什么go采用标记清除法而不是其他的方法>为什么Go采用标记清除法，而不是其他的方法？</a></li><li><a href=#什么是三色标记法mark-sweep>什么是三色标记法？mark-sweep</a></li><li><a href=#什么是根对象根对象有哪些>什么是根对象，根对象有哪些？</a></li><li><a href=#怎么的条件会触发go的gc>怎么的条件会触发Go的GC</a></li><li><a href=#go的gc有哪些优化>go的GC有哪些优化</a></li><li><a href=#写屏障write-barrier>写屏障(Write Barrier) </a></li><li><a href=#辅助gcmutator-assist>辅助GC(Mutator Assist) </a></li><li><a href=#代码gc编程>代码GC编程</a><ul><li><a href=#代码减少逃逸分析>代码减少逃逸分析：</a></li><li><a href=#代码简单直白制造inline机会>代码简单直白，制造inline机会</a></li><li><a href=#减少分配次数>减少分配次数</a></li><li><a href=#缓存对象>缓存对象</a></li></ul></li></ul></nav></div><section class=blog-content><h2 id=什么是gc>什么是GC</h2><blockquote><p>GC指一种自动的<a href=https://zh.wikipedia.org/wiki/%E8%A8%98%E6%86%B6%E9%AB%94%E7%AE%A1%E7%90%86>存储器管理</a>机制，当某个程序占用的一部分内存空间不再被这个程序访问时，这个程序会借助<strong>垃圾回收</strong>算法向操作系统归还这部分内存空间。垃圾回收器可以减轻程序员的负担，也减少程序中的错误。</p></blockquote><blockquote><p>-from wiki</p></blockquote><h2 id=垃圾回收算法有哪些-分别的优缺点>垃圾回收算法有哪些 分别的优缺点</h2><p>================</p><h2 id=引用计数法>引用计数法</h2><hr><p>对每个对象设置引用计数，当对象被引用+1，失去引用/销毁-1，当计数为0的时回收对象内存</p><p>优点：简单直接，回收速度快</p><p>缺点：需要额外空间维护引用计数，无法解决对象的循环引用问题</p><h2 id=标记清除法>标记清除法</h2><hr><p>从根对象开始遍历所有引用对象，引用的对象打上标记tag，遍历完成，将没有标记的进行回收</p><p>优点：解决引用计数法的缺点</p><p>缺点：会产生大量不连续的内存碎片，导致无法给大对象分配内存</p><h2 id=标记整理法>标记整理法</h2><hr><p>让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存</p><p>优点：不会产生内存碎片</p><p>缺点：需要移动大量对象，处理效率比较低。</p><h2 id=复制>#复制</h2><p>&ndash;</p><p>将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理</p><p>优点：不会产生内存碎片，每次清除针对的都是整块内存</p><p>缺点：只使用了内存的一半、移动对象需要耗费时间，效率低于标记清除法</p><h2 id=分代收集法>分代收集法</h2><hr><p>按照对象的生命周期长短划分代空间，生命周期长的放在老年代，生命周期短的放在新生代</p><p>优点：回收性能好</p><p>缺点：算法复杂</p><h2 id=go的垃圾回收采用是哪个gc方法>go的垃圾回收采用是哪个GC方法</h2><p>================</p><p>go采用的是标记清除法，核心就是标记出哪些是内存还在使用（被引用的），哪些内存不再使用（未被引用），把未被引用的内存回收掉，供后续内存分配使用。</p><p>暂时无法在飞书文档外展示此内容</p><p>特殊case：如果内存块存放的是指针，那还需要递归的进行标记，全部标记完后，只保留标记的内存，未被标记的内存全部进行回收</p><h2 id=为什么go采用标记清除法而不是其他的方法>为什么Go采用标记清除法，而不是其他的方法？</h2><p>======================</p><p>引用计数无法解决循环引用，排除</p><p>标记整理好处在于解决内存碎片化的问题，但是Go运行时的分配算法基于tcmalloc，基本上没有碎片问题，对于gc并没有提升</p><p>复制只能用一半的内存，还需要大量移动，效率低</p><p>分代收集的话也不适用，因为go的gc主要目标是新创建的对象上，即存活时间短更利回收，而不是频繁的检查所有对象</p><blockquote><p>逃逸分析：编译器决定内存分配的位置，不需要程序员指定。函数中申请一个新的对象</p></blockquote><blockquote><p>如果分配到栈，则函数执行结束就可自动将内存回收</p></blockquote><blockquote><p>如果分配到堆，则函数执行结束可交给GC(垃圾回收)处理</p></blockquote><p>go编译器的逃逸分析，将大部分新生对象存储在栈里面，直接被回收，生命周期短的对象直接回收并不需要gc处理，长期存在的/比较大的对象会分配到堆中，才被gc回收，所以分代回收并没有实质上提升</p><h2 id=什么是三色标记法mark-sweep>什么是三色标记法？mark-sweep</h2><p>===================</p><p>人为的用三种颜色好描述go的gc过程，内存中的对象并无颜色区分</p><p>三色对应了垃圾回收中的三种状态：</p><p>灰色：对象放入“标记队列”中等待（待处理的对象）</p><p>黑色：对象已被标记为使用</p><p>白色：对象未被标记</p><p>步骤：</p><ol><li><p>开始gc初，所有对象放入白色队列</p></li><li><p>从根对象开始遍历，将所有可达的对象，标记为灰色，放入灰色队列（待处理队列）</p></li><li><p>从灰色队列中取出灰色对象，将它引用的对象标记灰色放入灰色队列，它自己标黑色，放入黑色队列</p></li><li><p>重复步骤3，直到灰色队列为空，这时候白色对象是不可达对象，回收白色对象</p></li></ol><h2 id=什么是根对象根对象有哪些>什么是根对象，根对象有哪些？</h2><p>==============</p><ol><li><p>全局变量：程序在编译期就能确定的那些存在于程序整个生命周期的变量</p></li><li><p>执行栈：每个 goroutine 都包含自己的执行栈，这些执行栈上包含栈上的变量及指向分配的堆内存区块的指针</p></li><li><p>寄存器：寄存器的值可能表示一个指针，参与计算的这些指针可能指向某些赋值器分配的堆内存区块</p></li></ol><h2 id=怎么的条件会触发go的gc>怎么的条件会触发Go的GC</h2><p>=============</p><ul><li>GOGC threshold</li></ul><p>每次内存分配时检查当前内存分配量是否达到阀值，达到则会触发gc</p><p>阀值 = 上次gc内存分配量 * 内存增长率</p><p>内存增长率是由环境变量GCGO控制，默认是100，即当内存扩大一倍的时候启动gc</p><ul><li>runtime.GC()</li></ul><p>类似Java的system.gc api手动代码触发gc</p><ul><li>runtime.forcegcperiod（2min）</li></ul><p>强制定期gc，默认2min触发一次gc，在runtime/proc.go:forcegcperiod</p><h2 id=go的gc有哪些优化>go的GC有哪些优化</h2><p>==========</p><p>标记-清理需要stw，需要暂停所有的goruntine，做gc然后再恢复。</p><p>减少stw时间，可以提升go的gc性能</p><h2 id=写屏障write-barrier>写屏障(Write Barrier) </h2><p>本质就是每次内存写操作时候，额外执行一小段代码</p><p>写屏障就是让goroutine与GC同时运行的手段，虽然写屏障不能完全消除stw，但是可以大大减少stw时间，类似开关，gc的特定时候开启，开启后指针传递时，把指针标记，即本轮不回收，下次gc再确定</p><h2 id=辅助gcmutator-assist>辅助GC(Mutator Assist) </h2><blockquote><p>为了防止内存分配过快，在GC执行过程中，如果goroutine需要分配内存，那么这个goroutine会参与一部分GC的 工作，即帮助GC做一部分工作，这个机制叫作Mutator Assist</p></blockquote><h2 id=代码gc编程>代码GC编程</h2><p>多制造inline的机会，将新对象尽可能都分配到栈而不是堆，因为go实现了退栈即释放，不影响gc</p><h3 id=代码减少逃逸分析>代码减少逃逸分析：</h3><ol><li><p>尽量使用局部变量（编译器会根据变量是否被外部引用来决定是否逃逸）</p></li><li><p>参数、返回数值传递值（传指针还是数值，需要修改原值或者内存比较大结构体传指针，而对于只读的占内存较少的结构体，传值获取较好性能）</p></li></ol><h3 id=代码简单直白制造inline机会>代码简单直白，制造inline机会</h3><h3 id=减少分配次数>减少分配次数</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>a</span> = make([]<span style=color:#66d9ef>int</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1234</span>)
</span></span><span style=display:flex><span><span style=color:#a6e22e>b</span> = make(<span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>string</span>]<span style=color:#66d9ef>int</span>, <span style=color:#ae81ff>2048</span>)
</span></span></code></pre></div><h3 id=缓存对象>缓存对象</h3><h1 id=什么是inline>什么是inline</h1><blockquote><p><strong>内联扩展</strong>或<strong>内联</strong>是一种手动或<a href=https://en.wikipedia.org/wiki/Compiler_optimization>编译器优化</a>，它用被调用函数的主体替换函数<a href=https://en.wikipedia.org/wiki/Call_site>调用站点</a></p></blockquote><blockquote><p>from wiki</p></blockquote><p>通过参数-gflags="-m"查看</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>add</span> (<span style=color:#a6e22e>x</span>, <span style=color:#a6e22e>y</span> <span style=color:#66d9ef>int</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>x</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>y</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>x</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>y</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>a</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>x</span>,<span style=color:#a6e22e>y</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.println(<span style=color:#a6e22e>a</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>\</span><span style=color:#f92672>-</span><span style=color:#960050;background-color:#1e0010>\</span><span style=color:#f92672>-</span><span style=color:#960050;background-color:#1e0010>\</span><span style=color:#f92672>-</span><span style=color:#960050;background-color:#1e0010>\</span><span style=color:#f92672>-</span><span style=color:#960050;background-color:#1e0010>\</span><span style=color:#f92672>-</span><span style=color:#960050;background-color:#1e0010>\</span><span style=color:#f92672>-</span><span style=color:#960050;background-color:#1e0010>\</span><span style=color:#f92672>-</span><span style=color:#960050;background-color:#1e0010>\</span><span style=color:#f92672>-</span><span style=color:#960050;background-color:#1e0010>\</span><span style=color:#f92672>-</span><span style=color:#960050;background-color:#1e0010>\</span><span style=color:#f92672>-</span><span style=color:#960050;background-color:#1e0010>\</span><span style=color:#f92672>-</span><span style=color:#960050;background-color:#1e0010>\</span><span style=color:#f92672>-</span><span style=color:#960050;background-color:#1e0010>\</span><span style=color:#f92672>-</span><span style=color:#960050;background-color:#1e0010>\</span><span style=color:#f92672>-</span><span style=color:#960050;background-color:#1e0010>\</span><span style=color:#f92672>-</span><span style=color:#960050;background-color:#1e0010>\</span><span style=color:#f92672>-</span><span style=color:#960050;background-color:#1e0010>\</span><span style=color:#f92672>-</span><span style=color:#960050;background-color:#1e0010>\</span><span style=color:#f92672>-</span><span style=color:#960050;background-color:#1e0010>\</span><span style=color:#f92672>-</span><span style=color:#960050;background-color:#1e0010>\</span><span style=color:#f92672>-</span><span style=color:#960050;background-color:#1e0010>\</span><span style=color:#f92672>-</span><span style=color:#960050;background-color:#1e0010>\</span><span style=color:#f92672>-</span><span style=color:#960050;background-color:#1e0010>\</span><span style=color:#f92672>-</span><span style=color:#960050;background-color:#1e0010>\</span><span style=color:#f92672>-</span><span style=color:#960050;background-color:#1e0010>\</span><span style=color:#f92672>-</span><span style=color:#960050;background-color:#1e0010>\</span><span style=color:#f92672>-</span><span style=color:#960050;background-color:#1e0010>\</span><span style=color:#f92672>-</span><span style=color:#960050;background-color:#1e0010>\</span><span style=color:#f92672>-</span><span style=color:#960050;background-color:#1e0010>\</span><span style=color:#f92672>-</span><span style=color:#960050;background-color:#1e0010>\</span><span style=color:#f92672>-</span><span style=color:#960050;background-color:#1e0010>\</span><span style=color:#f92672>-</span><span style=color:#960050;background-color:#1e0010>\</span><span style=color:#f92672>-</span><span style=color:#960050;background-color:#1e0010>\</span><span style=color:#f92672>-</span><span style=color:#960050;background-color:#1e0010>\</span><span style=color:#f92672>-</span><span style=color:#960050;background-color:#1e0010>\</span><span style=color:#f92672>-</span><span style=color:#960050;background-color:#1e0010>\</span><span style=color:#f92672>-</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>x</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>y</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>//inline function add replace by the body of the function
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>a</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>x</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>y</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.println(<span style=color:#a6e22e>a</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>不用使用内联的case：闭包调用、select、for、defer、go关键词创建的协程</p><p>总结：采用越简单的实现，对于傻瓜式语言性能越好</p><h1 id=逃逸分析>逃逸分析</h1><p>通过命令go build -gcflags &lsquo;-m&rsquo;命令查看</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>refs</span> = make([]<span style=color:#f92672>*</span><span style=color:#66d9ef>int</span>, <span style=color:#ae81ff>32</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>fc</span>()  {
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>refs</span>[<span style=color:#ae81ff>0</span>] = new(<span style=color:#66d9ef>int</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>fc</span>()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></section><div class=paginator><a class=prev href=https://hi-ernest.github.io/blog/the-loneliness-of-a-boat/><svg class="icon" width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M3.77086 21.1546C11.0491 22.698 21.4339 21.7773 21.4339 16.3608V4.63375c0-.69413-.075800000000001-1.3284-.2422-1.86588M3.77086 21.1546C1.9934 20.7777.973585 18.7264 1.08749 16.688c.17931-3.209.06972-7.25665-.08236-10.47293C.87809 3.52811 3.12891 1.16316 5.51029 1.25008c4.25565.15534 9.86671-.04779 13.28091-.24466 1.2952-.074686 2.0494.62843 2.4005 1.76245M3.77086 21.1546C4.56586 21.4723 5.49168 21.7879 6.5 22.0658M21.1917 2.76787c1.918 1.4143 1.9383 9.65123 1.7087 13.59293-2.0526 7.6586-10.5943 7.3054-16.4004 5.705M21.1917 2.76787C21.7612 4.51192 22.7203 9.67216 22 16.3608 21.2797 23.0494 11.3665 22.9511 6.5 22.0658M9.94496 9C9.28897 9.61644 7.63215 10.997 6.04814 11.7966 5.98257 11.8297 5.98456 11.9753 6.05061 12.0063c1.00435.4716 2.8788 1.9201 3.89435 2.9937M6.44444 11.9667C8.86549 12.0608 14 12 16 11" stroke="currentcolor" stroke-linecap="round"/></svg><span>一只船的孤独</span></a>
<a class=next href=https://hi-ernest.github.io/blog/2021-to-myself-next-year-today/><span>致明年今日的自己</span><svg class="icon" width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M3.77086 21.1546C11.0491 22.698 21.4339 21.7773 21.4339 16.3608V4.63375c0-.69413-.075800000000001-1.3284-.2422-1.86588M3.77086 21.1546C1.9934 20.7777.973585 18.7264 1.08749 16.688c.17931-3.209.06972-7.25665-.08236-10.47293C.87809 3.52811 3.12891 1.16316 5.51029 1.25008c4.25565.15534 9.86671-.04779 13.28091-.24466 1.2952-.074686 2.0494.62843 2.4005 1.76245M3.77086 21.1546C4.56586 21.4723 5.49168 21.7879 6.5 22.0658M21.1917 2.76787c1.918 1.4143 1.9383 9.65123 1.7087 13.59293-2.0526 7.6586-10.5943 7.3054-16.4004 5.705M21.1917 2.76787C21.7612 4.51192 22.7203 9.67216 22 16.3608 21.2797 23.0494 11.3665 22.9511 6.5 22.0658M12.055 9C12.711 9.61644 14.3679 10.997 15.9519 11.7966 16.0174 11.8297 16.0154 11.9753 15.9494 12.0063 14.945 12.4779 13.0706 13.9264 12.055 15m3.5006-3.0333C13.1345 12.0608 8 12 6 11" stroke="currentcolor" stroke-linecap="round"/></svg></a></div><div class=comments><script>const getTheme=window.localStorage&&window.localStorage.getItem("theme");let theme=getTheme==="dark"?"dark":"light",s=document.createElement("script");s.src="https://giscus.app/client.js",s.setAttribute("data-repo","hi-Ernest/blog-comments"),s.setAttribute("data-repo-id","R_kgDOKfq-Xw"),s.setAttribute("data-category","Announcements"),s.setAttribute("data-category-id","DIC_kwDOKfq-X84CaFwF"),s.setAttribute("data-mapping","pathname"),s.setAttribute("data-strict","0"),s.setAttribute("data-reactions-enabled","1"),s.setAttribute("data-emit-metadata","0"),s.setAttribute("data-input-position","top"),s.setAttribute("data-theme",theme),s.setAttribute("data-lang","zh-CN"),s.setAttribute("data-loading","lazy"),s.setAttribute("crossorigin","anonymous"),s.setAttribute("async",""),document.querySelector("div.comments").innerHTML="",document.querySelector("div.comments").appendChild(s)</script></div></article></div><footer class=footer><p>&copy; 2023 <a href=https://hi-ernest.github.io/>Always Exploring</a>
Powered by
<a href=https://gohugo.io/ rel=noopener target=_blank>Hugo️️</a>
<a href=https://github.com/guangzhengli/hugo-theme-ladder rel=noopener target=_blank>Ladder</a>
️</p></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M10.5376 22.7916C11.0152 22.7207 22.5795 21.1781 22.0978 10.4211 22.0536 9.43274 21.9303 8.53367 21.7387 7.71865M10.5376 22.7916C16.876 22.3728 20.0969 19.8899 21.5383 16.9142M10.5376 22.7916C9.7707 22.9055 8.97982 22.8964 8.19743 22.7725M21.7387 7.71865C21.4988 6.69828 21.1518 5.80967 20.7188 5.04257m1.0199 2.67608C22.6022 10.1105 23.0542 13.7848 21.5383 16.9142M20.7188 5.04257c-3.5504-6.28886-12.88753-4.410077-16.44303.0C2.88063 6.77451-.0433281 11.1668 1.38159 16.6571c.89322 3.4417 3.7911 5.6365 6.81584 6.1154M20.7188 5.04257c1.3509 1.89783 3.3111 6.34223 1.6353 10.37273M21.5383 16.9142C21.8737 16.4251 22.1428 15.9235 22.3541 15.4153M8.19743 22.7725C12.1971 23.4683 20.6281 22.971 22.3541 15.4153M14 10.945C13.3836 10.289 12.003 8.63215 11.2034 7.04814 11.1703 6.98257 11.0247 6.98456 10.9937 7.05061 10.5221 8.05496 9.07362 9.92941 8 10.945m3.0333-3.50056C10.9392 9.86549 11 15 12 17" stroke="currentcolor" stroke-linecap="round"/></svg></a><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const s=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="Copy";function n(){t.innerHTML="Copied",setTimeout(()=>{t.innerHTML="Copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),n();return}const s=document.createRange();s.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(s);try{document.execCommand("copy"),n()}catch{}o.removeRange(s)}),e.parentNode.appendChild(t)})</script></main></body><script src=https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.0.6/medium-zoom.min.js integrity="sha512-N9IJRoc3LaP3NDoiGkcPa4gG94kapGpaA5Zq9/Dr04uf5TbLFU5q0o8AbRhLKUUlp8QFS2u7S+Yti0U7QtuZvQ==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script>const images=Array.from(document.querySelectorAll(".blog-content img"));images.forEach(e=>{mediumZoom(e,{margin:10,scrollOffset:40,container:null,template:null,background:"rgba(0, 0, 0, 0.5)"})})</script><script src=/main.min.6bb26b69159420159c74dc9e097b06a578ed2b68c701466a91a44a9632d851bd0af167a1b30012387b4c512b48ad9ad4d3394e04d77ae38d57e1920fe4ed34fe.js integrity="sha512-a7JraRWUIBWcdNyeCXsGpXjtK2jHAUZqkaRKljLYUb0K8WehswASOHtMUStIrZrU0zlOBNd6441X4ZIP5O00/g==" crossorigin=anonymous defer></script></html>