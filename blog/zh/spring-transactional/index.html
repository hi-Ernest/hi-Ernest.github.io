<!doctype html><html lang=zh><head><meta name=viewport content="width=device-width,initial-scale=1"><title>Spring事务最佳实践【Java版】</title>
<meta charset=utf-8><meta name=description content="Ladder@背景
在开发需求采用Java声明式事务对两个对象插入两张表
下方代码编写，单测发现事务失效（release对象插入成功，action插入失败，但事务没有回滚，release对象还是插入成功）"><meta name=author content="hi-Ernest"><link rel=canonical href=https://hi-ernest.github.io/blog/zh/spring-transactional/><meta name=google-site-verification content="xxx"><link rel=alternate type=application/rss+xml href=https://hi-ernest.github.io//index.xml title="Always Exploring"><script async defer data-website-id=f3deb06c-5a53-49a7-a8e1-b4ce23c412ba src=https://umami-blog-analyze-30k29jpw4-hi-ernest.vercel.app/hugo-ladder></script><meta property="og:url" content="https://hi-ernest.github.io/blog/zh/spring-transactional/"><meta property="og:site_name" content="Always Exploring"><meta property="og:title" content="Spring事务最佳实践【Java版】"><meta property="og:description" content="背景 在开发需求采用Java声明式事务对两个对象插入两张表 下方代码编写，单测发现事务失效（release对象插入成功，action插入失败，但事务没有回滚，release对象还是插入成功）"><meta property="og:locale" content="zh"><meta property="og:type" content="article"><meta property="article:section" content="blog"><meta property="article:published_time" content="2023-11-28T09:34:00+08:00"><meta property="article:modified_time" content="2023-11-28T09:34:00+08:00"><meta property="article:tag" content="Java"><meta name=twitter:card content="summary"><meta name=twitter:title content="Spring事务最佳实践【Java版】"><meta name=twitter:description content="背景 在开发需求采用Java声明式事务对两个对象插入两张表 下方代码编写，单测发现事务失效（release对象插入成功，action插入失败，但事务没有回滚，release对象还是插入成功）"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Spring事务最佳实践【Java版】","item":"https://hi-ernest.github.io/blog/zh/spring-transactional/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Spring事务最佳实践【Java版】","name":"Spring事务最佳实践【Java版】","description":"背景 在开发需求采用Java声明式事务对两个对象插入两张表 下方代码编写，单测发现事务失效（release对象插入成功，action插入失败，但事务没有回滚，release对象还是插入成功）\n","keywords":["Java"],"articleBody":"背景 在开发需求采用Java声明式事务对两个对象插入两张表 下方代码编写，单测发现事务失效（release对象插入成功，action插入失败，但事务没有回滚，release对象还是插入成功）\n@Slf4j @Service public class xxService { public String xxx(xxRequest request) throws JsonProcessingException { // 参数校验 checkParam(request); // 前置查询校验信息... //省略xxx多行代码解析和build逻辑 // .... ReleaseEntity release = buildReleaseEntity(xxx); String reason = request.getReason(); ActionEntity action = buildActionEntity(xxx); // 执行db操作 execute(release, action) // 返回执行记录id return action.getUid(); } @Transactional(rollbackFor = Exception.class) public void execute(ReleaseEntity release, ActionEntity action) { try { // 新增release releaseService.create(release); // 新增action actionService.create(action); } catch (BizException | JsonProcessingException ex) { throw new BizException(\"执行流量分发报错,请重试err:\" + ex.getMessage()); } } } @Slf4j @Service public class ReleaseService { @Resource private ReleaseMapper releaseMapper; public void create(ReleaseEntity entity ) throws JsonProcessingException { log.info(\"新增执行版本 entity:{}\", JsonUtils.getMapper().writeValueAsString(entity)); try { releaseMapper.insertSelective(entity); } catch (Exception e) { throw new BizException(String.format(\"新增执行版本,请重试err:%s\", e.getMessage())); } } public List\u003cReleaseEntity\u003e getReleaseListByPlanId(String planId) { return releaseMapper.getReleaseListByPlanId(planId); } } @Slf4j @Service public class ActionService { @Resource private ActionMapper actionMapper; public void create(ActionEntity entity) throws JsonProcessingException { log.info(\"新增执行记录 entity:{}\", JsonUtils.getMapper().writeValueAsString(entity)); try { actionMapper.insertSelective(entity); } catch (Exception e) { throw new BizException(String.format(\"新增执行记录报错,请重试err:%s\", e.getMessage())); } } } 排查经过 尝试：将数据库操作函数代码放在函数distribute中，在distribute方法上增加@Transactional注解\n结论：执行单测，事务没有失效，成功事务回滚没有问题\n疑问思考：是不是spring方法中传递事物有什么黑魔法？如果按照这样写能实现需要会不会大事务（原则：尽可能事务的开启在db操作代码前后，尽可能缩小事务影响范围），还是spring会在运行到db操作代码时候，智能的开启事务和提交事务？？\n@Slf4j @Service public class RgwService { @Transactional(rollbackFor = Exception.class) public String distribute(DistributeRequest request) throws JsonProcessingException { // 参数校验 checkDistributeParam(request); // 前置查询校验预案信息... //省略xxx多行代码解析和build逻辑 // .... ReleaseEntity release = buildReleaseEntity(planId, newParam, description, operator, curReleaseVersion); String reason = request.getReason(); ActionEntity action = buildActionEntity(planId, release.getUid(), reason, operator); // 执行db操作 execute(release, action) try { // 新增release releaseService.create(release); // 新增action actionService.create(action); } catch (BizException | JsonProcessingException ex) { throw new BizException(\"执行流量分发报错,请重试err:\" + ex.getMessage()); } } // 返回执行记录id return action.getUid(); } } 问题根因 由于使用Spring AOP代理造成的，因为只有当事务方法被当前类以外的代码调用时，才会由Spring生成的代理对象来管理 ps：在springAOP的用法中，只有代理的类才会被切入，我们在controller层调用service的方法的时候，是可以被切入的， 但是如果我们在service层 A方法中，调用B方法，切点切的是B方法，那么这时候是不会切入的\n解决方式 使用编程式事务管理 在这种方式下，我们显式地管理事务，手动开启、提交和回滚事务，确保methodA和methodB都能在自己的事务中执行\n优点 1. 更细粒度的控制控制事务影响范围 2. 方便处理条件式回滚可以 3. 手动处理特定的异常 缺点 1. 代码冗余：开启事务、提交事务、回滚事务和异常处理等 2. 可读性差：事务的边界和处理通常会散布在业务逻辑中 @Service public class MyService { @Autowired private PlatformTransactionManager transactionManager; public void methodA() { DefaultTransactionDefinition def = new DefaultTransactionDefinition(); TransactionStatus status = transactionManager.getTransaction(def); try { // 执行一些业务逻辑 // 调用methodB methodB(); transactionManager.commit(status); } catch (Exception e) { transactionManager.rollback(status); throw e; } } @Transactional public void methodB() { // 执行一些业务逻辑 // 抛出异常 throw new RuntimeException(\"Something went wrong\"); } } 拆分到不同的类中 通过将methodA和methodB拆分到不同的类中，每个方法都有自己的代理，事务注解不会相互影响，可以正常工作。\n优点 简单明了，易于维护，不需要复杂的额外配置；不需要显式的编程式事务管理或AOP配置 缺点 容易冗余多个类，职责不清晰 @Service public class MyService { @Autowired private MyOtherService otherService; @Transactional public void methodA() { // 执行一些业务逻辑 // 调用MyOtherService中的methodB otherService.methodB(); } } @Service public class MyOtherService { @Transactional public void methodB() { // 执行一些业务逻辑 // 抛出异常 throw new RuntimeException(\"Something went wrong\"); } } 使用ApplicationContext获取当前代理对象 使用ApplicationContext来获取Bean的实例，从而确保事务生效；就是在该类中自动注入本类bean，使用@Autowired即可，然后使用这个注入的bean去调用本类方法，即可达到两方法事务都起效\n优点 不需要引入额外的配置或依赖于特定的AOP框架功能 缺点 1. 潜在性能问题：一定的性能开销，因为它需要在运行时动态确定Bean的实例 2. 可读性差：读者可能难以理解为什么需要在同一个类中的方法之间使用它 3. 潜在的递归问题： 需要小心避免在同一个方法内部产生无限递归调用问题，导致栈溢出异常 import org.springframework.beans.BeansException; import org.springframework.context.ApplicationContext; import org.springframework.context.ApplicationContextAware; import org.springframework.stereotype.Service; import org.springframework.transaction.annotation.Transactional; @Service public class MyService implements ApplicationContextAware { private ApplicationContext applicationContext; @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException { this.applicationContext = applicationContext; } @Transactional public void methodA() { // 执行一些业务逻辑 // 获取MyService的代理实例 MyService proxy = applicationContext.getBean(MyService.class); // 调用methodB proxy.methodB(); } @Transactional public void methodB() { // 执行一些业务逻辑 // 抛出异常 throw new RuntimeException(\"Something went wrong\"); } } 使用AopContext.currentProxy()获取当前代理对象【推荐】 methodA中使用了AopContext.currentProxy()获取了当前代理对象，并调用了methodB。这样，methodB将会在相同的事务中执行，而不会失效\n优点 简化代码；避免了不必要的类拆分和编程式事务代码 缺点 1. 潜在性能问题：引入一定的性能开销，因为它需要在运行时动态确定代理对象。这可能对高性能应用程序产生一定影响，特别是在高并发case 2. 线程安全问题：可能会引入线程安全问题，因为它涉及到共享状态（当前代理对象）。在多线程应用中，需要谨慎使用，并确保适当的同步机制可读性差 import org.springframework.aop.framework.AopContext; import org.springframework.stereotype.Service; import org.springframework.transaction.annotation.Transactional; @Service @EnableAspectJAutoProxy(proxyTargetClass = true, exposeProxy = true) public class MyService { @Transactional public void methodA() { // 执行一些业务逻辑 // 调用methodB MyService proxy = (MyService) AopContext.currentProxy(); proxy.methodB(); } @Transactional public void methodB() { // 执行一些业务逻辑 // 抛出异常 throw new RuntimeException(\"Something went wrong\"); } } 其他资料 ","wordCount":"2239","inLanguage":"zh","datePublished":"2023-11-28T09:34:00+08:00","dateModified":"2023-11-28T09:34:00+08:00","author":{"@type":"Person","name":"hi-Ernest"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://hi-ernest.github.io/blog/zh/spring-transactional/"},"publisher":{"@type":"Organization","name":"Always Exploring","logo":{"@type":"ImageObject","url":"https://hi-ernest.github.io/favicon.ico"}}}</script><link rel=icon href=/images/avatar.png sizes=16x16><link rel=apple-touch-icon href=/images/avatar.png><link rel=manifest href=/images/avatar.png><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/lxgw-wenkai-webfont@1.7.0/style.css><link rel=stylesheet href=/css/main.min.ec28f09e946fc0df77c187fcd0d0ebde58fca6de8efb8e1620f3d45c32d4da88.css integrity="sha256-7CjwnpRvwN93wYf80NDr3lj8pt6O+44WIPPUXDLU2og=" crossorigin=anonymous media=screen><link rel=stylesheet href=/scss/highlight/github-dark.min.min.66034289ee9a113219a2c4aae0a8bd2095ab255c832a42efcf5863f10814e7a1.css><script src=/js/highlight.min.min.c607d6febd16934a82eb61d3a896ed9d869f54373cc63ce95864ed5488fe3128.js></script><script>hljs.highlightAll()</script><script>(()=>{var t=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches,e=localStorage.getItem("theme");t&&e===null&&(localStorage.setItem("theme","dark"),document.documentElement.setAttribute("data-dark-mode","")),t&&e==="dark"&&document.documentElement.setAttribute("data-dark-mode",""),e==="dark"&&document.documentElement.setAttribute("data-dark-mode","")})()</script></head><body><main class=wrapper><nav class=navigation><section class=container><a class=navigation-brand href=/>主页
</a><input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><span></span><span></span><span></span></label><ul class=navigation-list id=navigation-list><li class="navigation-item navigation-menu"><a class=navigation-link href=/blog>文章</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=/art>短想法</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=/archives>历史</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=/guestbook>留言板</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=https://umami-blog-analyze-30k29jpw4-hi-ernest.vercel.app/share/F0HNiV8DX3mdMGa3/hi-Ernest>统计</a></li><li class="navigation-item menu-separator"><span>|</span></li><li class="navigation-item navigation-dark"><button id=mode type=button aria-label="toggle user light or dark theme">
<span class=toggle-dark><svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-moon"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg></span>
<span class=toggle-light><svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-sun"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></span></button></li><li class="navigation-item navigation-language"><a href=https://hi-ernest.github.io/en/>EN</a></li></ul></section></nav><div id=content><article class=blog-single><header class=blog-title><h1>Spring事务最佳实践【Java版】</h1></header><p><small>2023年11月28日&nbsp;· 2239 字&nbsp;· 5 分钟</small>
<small>·
<a href=https://hi-ernest.github.io/tags/java/>Java</a></small><p><div class=blog-toc><nav id=TableOfContents><ul><li><a href=#背景>背景</a></li><li><a href=#排查经过>排查经过</a></li><li><a href=#问题根因>问题根因</a></li><li><a href=#解决方式>解决方式</a><ul><li><a href=#使用编程式事务管理>使用编程式事务管理</a></li><li><a href=#拆分到不同的类中>拆分到不同的类中</a></li><li><a href=#使用applicationcontext获取当前代理对象>使用ApplicationContext获取当前代理对象</a></li><li><a href=#使用aopcontextcurrentproxy获取当前代理对象推荐>使用AopContext.currentProxy()获取当前代理对象【推荐】</a></li></ul></li><li><a href=#其他资料>其他资料</a></li></ul></nav></div><section class=blog-content><h2 id=背景>背景</h2><p>在开发需求采用Java声明式事务对两个对象插入两张表
下方代码编写，单测发现事务失效（release对象插入成功，action插入失败，但事务没有回滚，release对象还是插入成功）</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Slf4j</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Service</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>xxService</span> {
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> String <span style=color:#a6e22e>xxx</span>(xxRequest request) <span style=color:#66d9ef>throws</span> JsonProcessingException {
</span></span><span style=display:flex><span>         <span style=color:#75715e>// 参数校验</span>
</span></span><span style=display:flex><span>         checkParam(request);
</span></span><span style=display:flex><span>         <span style=color:#75715e>// 前置查询校验信息...</span>
</span></span><span style=display:flex><span>         <span style=color:#75715e>//省略xxx多行代码解析和build逻辑</span>
</span></span><span style=display:flex><span>         <span style=color:#75715e>// ....</span>
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>        ReleaseEntity release <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>            buildReleaseEntity(xxx);
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>        String reason <span style=color:#f92672>=</span> request.<span style=color:#a6e22e>getReason</span>();
</span></span><span style=display:flex><span>        ActionEntity action <span style=color:#f92672>=</span> buildActionEntity(xxx);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 执行db操作</span>
</span></span><span style=display:flex><span>execute(release, action)
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 返回执行记录id</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> action.<span style=color:#a6e22e>getUid</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>     
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Transactional</span>(rollbackFor <span style=color:#f92672>=</span> Exception.<span style=color:#a6e22e>class</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>execute</span>(ReleaseEntity release, ActionEntity action) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>          <span style=color:#75715e>// 新增release</span>
</span></span><span style=display:flex><span>releaseService.<span style=color:#a6e22e>create</span>(release);
</span></span><span style=display:flex><span>          <span style=color:#75715e>// 新增action</span>
</span></span><span style=display:flex><span>actionService.<span style=color:#a6e22e>create</span>(action);
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>catch</span> (BizException <span style=color:#f92672>|</span> JsonProcessingException ex) {
</span></span><span style=display:flex><span>              <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> BizException(<span style=color:#e6db74>&#34;执行流量分发报错,请重试err:&#34;</span> <span style=color:#f92672>+</span> ex.<span style=color:#a6e22e>getMessage</span>());
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Slf4j</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Service</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ReleaseService</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Resource</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> ReleaseMapper releaseMapper;
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>create</span>(ReleaseEntity entity ) <span style=color:#66d9ef>throws</span> JsonProcessingException {
</span></span><span style=display:flex><span>        log.<span style=color:#a6e22e>info</span>(<span style=color:#e6db74>&#34;新增执行版本 entity:{}&#34;</span>, JsonUtils.<span style=color:#a6e22e>getMapper</span>().<span style=color:#a6e22e>writeValueAsString</span>(entity));
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>            releaseMapper.<span style=color:#a6e22e>insertSelective</span>(entity);
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>catch</span> (Exception e) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> BizException(String.<span style=color:#a6e22e>format</span>(<span style=color:#e6db74>&#34;新增执行版本,请重试err:%s&#34;</span>, e.<span style=color:#a6e22e>getMessage</span>()));
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> List<span style=color:#f92672>&lt;</span>ReleaseEntity<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>getReleaseListByPlanId</span>(String planId) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> releaseMapper.<span style=color:#a6e22e>getReleaseListByPlanId</span>(planId);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Slf4j</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Service</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ActionService</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>@Resource</span> <span style=color:#66d9ef>private</span> ActionMapper actionMapper;
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>create</span>(ActionEntity entity) <span style=color:#66d9ef>throws</span> JsonProcessingException {
</span></span><span style=display:flex><span>    log.<span style=color:#a6e22e>info</span>(<span style=color:#e6db74>&#34;新增执行记录 entity:{}&#34;</span>, JsonUtils.<span style=color:#a6e22e>getMapper</span>().<span style=color:#a6e22e>writeValueAsString</span>(entity));
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>      actionMapper.<span style=color:#a6e22e>insertSelective</span>(entity);
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>catch</span> (Exception e) {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> BizException(String.<span style=color:#a6e22e>format</span>(<span style=color:#e6db74>&#34;新增执行记录报错,请重试err:%s&#34;</span>, e.<span style=color:#a6e22e>getMessage</span>()));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=排查经过>排查经过</h2><p>尝试：将数据库操作函数代码放在函数distribute中，在distribute方法上增加@Transactional注解</p><p>结论：执行单测，事务没有失效，成功事务回滚没有问题</p><blockquote><p>疑问思考：是不是spring方法中传递事物有什么黑魔法？如果按照这样写能实现需要会不会大事务（原则：尽可能事务的开启在db操作代码前后，尽可能缩小事务影响范围），还是spring会在运行到db操作代码时候，智能的开启事务和提交事务？？</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Slf4j</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Service</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>RgwService</span> {
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Transactional</span>(rollbackFor <span style=color:#f92672>=</span> Exception.<span style=color:#a6e22e>class</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> String <span style=color:#a6e22e>distribute</span>(DistributeRequest request) <span style=color:#66d9ef>throws</span> JsonProcessingException {
</span></span><span style=display:flex><span>         <span style=color:#75715e>// 参数校验</span>
</span></span><span style=display:flex><span>         checkDistributeParam(request);
</span></span><span style=display:flex><span>         <span style=color:#75715e>// 前置查询校验预案信息...</span>
</span></span><span style=display:flex><span>         <span style=color:#75715e>//省略xxx多行代码解析和build逻辑</span>
</span></span><span style=display:flex><span>         <span style=color:#75715e>// ....</span>
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>        ReleaseEntity release <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>            buildReleaseEntity(planId, newParam, description, operator, curReleaseVersion);
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>        String reason <span style=color:#f92672>=</span> request.<span style=color:#a6e22e>getReason</span>();
</span></span><span style=display:flex><span>        ActionEntity action <span style=color:#f92672>=</span> buildActionEntity(planId, release.<span style=color:#a6e22e>getUid</span>(), reason, operator);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 执行db操作</span>
</span></span><span style=display:flex><span>execute(release, action)
</span></span><span style=display:flex><span><span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>          <span style=color:#75715e>// 新增release</span>
</span></span><span style=display:flex><span>          releaseService.<span style=color:#a6e22e>create</span>(release);
</span></span><span style=display:flex><span>          <span style=color:#75715e>// 新增action</span>
</span></span><span style=display:flex><span>          actionService.<span style=color:#a6e22e>create</span>(action);
</span></span><span style=display:flex><span>         } <span style=color:#66d9ef>catch</span> (BizException <span style=color:#f92672>|</span> JsonProcessingException ex) {
</span></span><span style=display:flex><span>              <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> BizException(<span style=color:#e6db74>&#34;执行流量分发报错,请重试err:&#34;</span> <span style=color:#f92672>+</span> ex.<span style=color:#a6e22e>getMessage</span>());
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>          }
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 返回执行记录id</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> action.<span style=color:#a6e22e>getUid</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=问题根因>问题根因</h2><p>由于使用Spring AOP代理造成的，因为只有当事务方法被当前类以外的代码调用时，才会由Spring生成的代理对象来管理
ps：在springAOP的用法中，只有代理的类才会被切入，我们在controller层调用service的方法的时候，是可以被切入的， 但是如果我们在service层 A方法中，调用B方法，切点切的是B方法，那么这时候是不会切入的</p><h2 id=解决方式>解决方式</h2><h3 id=使用编程式事务管理>使用编程式事务管理</h3><p>在这种方式下，我们显式地管理事务，手动开启、提交和回滚事务，确保methodA和methodB都能在自己的事务中执行</p><table><thead><tr><th>优点</th></tr></thead><tbody><tr><td>1. 更细粒度的控制控制事务影响范围</td></tr><tr><td>2. 方便处理条件式回滚可以</td></tr><tr><td>3. 手动处理特定的异常</td></tr></tbody></table><table><thead><tr><th>缺点</th></tr></thead><tbody><tr><td>1. 代码冗余：开启事务、提交事务、回滚事务和异常处理等</td></tr><tr><td>2. 可读性差：事务的边界和处理通常会散布在业务逻辑中</td></tr></tbody></table><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Service</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyService</span> {
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Autowired</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> PlatformTransactionManager transactionManager;
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>methodA</span>() {
</span></span><span style=display:flex><span>        DefaultTransactionDefinition def <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> DefaultTransactionDefinition();
</span></span><span style=display:flex><span>        TransactionStatus status <span style=color:#f92672>=</span> transactionManager.<span style=color:#a6e22e>getTransaction</span>(def);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 执行一些业务逻辑</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 调用methodB</span>
</span></span><span style=display:flex><span>            methodB();
</span></span><span style=display:flex><span>            transactionManager.<span style=color:#a6e22e>commit</span>(status);
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>catch</span> (Exception e) {
</span></span><span style=display:flex><span>            transactionManager.<span style=color:#a6e22e>rollback</span>(status);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>throw</span> e;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Transactional</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>methodB</span>() {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 执行一些业务逻辑</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 抛出异常</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> RuntimeException(<span style=color:#e6db74>&#34;Something went wrong&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=拆分到不同的类中>拆分到不同的类中</h3><p>通过将methodA和methodB拆分到不同的类中，每个方法都有自己的代理，事务注解不会相互影响，可以正常工作。</p><table><thead><tr><th>优点</th></tr></thead><tbody><tr><td>简单明了，易于维护，不需要复杂的额外配置；不需要显式的编程式事务管理或AOP配置</td></tr></tbody></table><table><thead><tr><th>缺点</th></tr></thead><tbody><tr><td>容易冗余多个类，职责不清晰</td></tr></tbody></table><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Service</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyService</span> {
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Autowired</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> MyOtherService otherService;
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Transactional</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>methodA</span>() {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 执行一些业务逻辑</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 调用MyOtherService中的methodB</span>
</span></span><span style=display:flex><span>        otherService.<span style=color:#a6e22e>methodB</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Service</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyOtherService</span> {
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Transactional</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>methodB</span>() {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 执行一些业务逻辑</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 抛出异常</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> RuntimeException(<span style=color:#e6db74>&#34;Something went wrong&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=使用applicationcontext获取当前代理对象>使用ApplicationContext获取当前代理对象</h3><p>使用ApplicationContext来获取Bean的实例，从而确保事务生效；就是在该类中自动注入本类bean，使用@Autowired即可，然后使用这个注入的bean去调用本类方法，即可达到两方法事务都起效</p><table><thead><tr><th>优点</th></tr></thead><tbody><tr><td>不需要引入额外的配置或依赖于特定的AOP框架功能</td></tr></tbody></table><table><thead><tr><th>缺点</th></tr></thead><tbody><tr><td>1. 潜在性能问题：一定的性能开销，因为它需要在运行时动态确定Bean的实例</td></tr><tr><td>2. 可读性差：读者可能难以理解为什么需要在同一个类中的方法之间使用它</td></tr><tr><td>3. 潜在的递归问题： 需要小心避免在同一个方法内部产生无限递归调用问题，导致栈溢出异常</td></tr></tbody></table><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>import</span> org.springframework.beans.BeansException;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> org.springframework.context.ApplicationContext;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> org.springframework.context.ApplicationContextAware;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> org.springframework.stereotype.Service;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> org.springframework.transaction.annotation.Transactional;
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Service</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyService</span> <span style=color:#66d9ef>implements</span> ApplicationContextAware {
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span> ApplicationContext applicationContext;
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>setApplicationContext</span>(ApplicationContext applicationContext) <span style=color:#66d9ef>throws</span> BeansException {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>applicationContext</span> <span style=color:#f92672>=</span> applicationContext;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Transactional</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>methodA</span>() {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 执行一些业务逻辑</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 获取MyService的代理实例</span>
</span></span><span style=display:flex><span>        MyService proxy <span style=color:#f92672>=</span> applicationContext.<span style=color:#a6e22e>getBean</span>(MyService.<span style=color:#a6e22e>class</span>);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 调用methodB</span>
</span></span><span style=display:flex><span>        proxy.<span style=color:#a6e22e>methodB</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Transactional</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>methodB</span>() {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 执行一些业务逻辑</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 抛出异常</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> RuntimeException(<span style=color:#e6db74>&#34;Something went wrong&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=使用aopcontextcurrentproxy获取当前代理对象推荐>使用AopContext.currentProxy()获取当前代理对象【推荐】</h3><p>methodA中使用了AopContext.currentProxy()获取了当前代理对象，并调用了methodB。这样，methodB将会在相同的事务中执行，而不会失效</p><table><thead><tr><th>优点</th></tr></thead><tbody><tr><td>简化代码；避免了不必要的类拆分和编程式事务代码</td></tr></tbody></table><table><thead><tr><th>缺点</th></tr></thead><tbody><tr><td>1. 潜在性能问题：引入一定的性能开销，因为它需要在运行时动态确定代理对象。这可能对高性能应用程序产生一定影响，特别是在高并发case</td></tr><tr><td>2. 线程安全问题：可能会引入线程安全问题，因为它涉及到共享状态（当前代理对象）。在多线程应用中，需要谨慎使用，并确保适当的同步机制可读性差</td></tr></tbody></table><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>import</span> org.springframework.aop.framework.AopContext;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> org.springframework.stereotype.Service;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> org.springframework.transaction.annotation.Transactional;
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Service</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@EnableAspectJAutoProxy</span>(proxyTargetClass <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>, exposeProxy <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>) 
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyService</span> {
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Transactional</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>methodA</span>() {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 执行一些业务逻辑</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 调用methodB</span>
</span></span><span style=display:flex><span>        MyService proxy <span style=color:#f92672>=</span> (MyService) AopContext.<span style=color:#a6e22e>currentProxy</span>();
</span></span><span style=display:flex><span>        proxy.<span style=color:#a6e22e>methodB</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Transactional</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>methodB</span>() {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 执行一些业务逻辑</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 抛出异常</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> RuntimeException(<span style=color:#e6db74>&#34;Something went wrong&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=其他资料>其他资料</h2><p><img src=https://cdn.jsdelivr.net/gh/hi-Ernest/imgbed/images/202312052347147.png alt></p></section><div class=paginator><a class=prev href=https://hi-ernest.github.io/blog/zh/six-goals/><svg class="icon" width="24" height="24" viewBox="0 0 24 24" fill="none"><path d="M3.77086 21.1546C11.0491 22.698 21.4339 21.7773 21.4339 16.3608V4.63375c0-.69413-.075800000000001-1.3284-.2422-1.86588M3.77086 21.1546C1.9934 20.7777.973585 18.7264 1.08749 16.688c.17931-3.209.06972-7.25665-.08236-10.47293C.87809 3.52811 3.12891 1.16316 5.51029 1.25008c4.25565.15534 9.86671-.04779 13.28091-.24466 1.2952-.074686 2.0494.62843 2.4005 1.76245M3.77086 21.1546C4.56586 21.4723 5.49168 21.7879 6.5 22.0658M21.1917 2.76787c1.918 1.4143 1.9383 9.65123 1.7087 13.59293-2.0526 7.6586-10.5943 7.3054-16.4004 5.705M21.1917 2.76787C21.7612 4.51192 22.7203 9.67216 22 16.3608 21.2797 23.0494 11.3665 22.9511 6.5 22.0658M9.94496 9C9.28897 9.61644 7.63215 10.997 6.04814 11.7966 5.98257 11.8297 5.98456 11.9753 6.05061 12.0063c1.00435.4716 2.8788 1.9201 3.89435 2.9937M6.44444 11.9667C8.86549 12.0608 14 12 16 11" stroke="currentcolor" stroke-linecap="round"/></svg>
<span>六个想要达成的目标</span></a>
<a class=next href=https://hi-ernest.github.io/blog/zh/25-years-old/><span>26岁!</span><svg class="icon" width="24" height="24" viewBox="0 0 24 24" fill="none"><path d="M3.77086 21.1546C11.0491 22.698 21.4339 21.7773 21.4339 16.3608V4.63375c0-.69413-.075800000000001-1.3284-.2422-1.86588M3.77086 21.1546C1.9934 20.7777.973585 18.7264 1.08749 16.688c.17931-3.209.06972-7.25665-.08236-10.47293C.87809 3.52811 3.12891 1.16316 5.51029 1.25008c4.25565.15534 9.86671-.04779 13.28091-.24466 1.2952-.074686 2.0494.62843 2.4005 1.76245M3.77086 21.1546C4.56586 21.4723 5.49168 21.7879 6.5 22.0658M21.1917 2.76787c1.918 1.4143 1.9383 9.65123 1.7087 13.59293-2.0526 7.6586-10.5943 7.3054-16.4004 5.705M21.1917 2.76787C21.7612 4.51192 22.7203 9.67216 22 16.3608 21.2797 23.0494 11.3665 22.9511 6.5 22.0658M12.055 9C12.711 9.61644 14.3679 10.997 15.9519 11.7966 16.0174 11.8297 16.0154 11.9753 15.9494 12.0063 14.945 12.4779 13.0706 13.9264 12.055 15m3.5006-3.0333C13.1345 12.0608 8 12 6 11" stroke="currentcolor" stroke-linecap="round"/></svg></a></div><div class=comments><script>const getTheme=window.localStorage&&window.localStorage.getItem("theme");let theme=getTheme==="dark"?"dark":"light",s=document.createElement("script");s.src="https://giscus.app/client.js",s.setAttribute("data-repo","hi-Ernest/blog-comments"),s.setAttribute("data-repo-id","R_kgDOKfq-Xw"),s.setAttribute("data-category","Announcements"),s.setAttribute("data-category-id","DIC_kwDOKfq-X84CaFwF"),s.setAttribute("data-mapping","pathname"),s.setAttribute("data-strict","0"),s.setAttribute("data-reactions-enabled","1"),s.setAttribute("data-emit-metadata","0"),s.setAttribute("data-input-position","top"),s.setAttribute("data-theme",theme),s.setAttribute("data-lang","zh-CN"),s.setAttribute("data-loading","lazy"),s.setAttribute("crossorigin","anonymous"),s.setAttribute("async",""),document.querySelector("div.comments").innerHTML="",document.querySelector("div.comments").appendChild(s)</script></div></article></div><footer class=footer><p>&copy; 2024 <a href=https://hi-ernest.github.io/>Always Exploring</a>
Powered by
<a href=https://gohugo.io/ rel=noopener target=_blank>Hugo️️</a>
<a href=https://github.com/guangzhengli/hugo-theme-ladder rel=noopener target=_blank>Ladder</a>
️</p></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg width="24" height="24" viewBox="0 0 24 24" fill="none"><path d="M10.5376 22.7916C11.0152 22.7207 22.5795 21.1781 22.0978 10.4211 22.0536 9.43274 21.9303 8.53367 21.7387 7.71865M10.5376 22.7916C16.876 22.3728 20.0969 19.8899 21.5383 16.9142M10.5376 22.7916C9.7707 22.9055 8.97982 22.8964 8.19743 22.7725M21.7387 7.71865C21.4988 6.69828 21.1518 5.80967 20.7188 5.04257m1.0199 2.67608C22.6022 10.1105 23.0542 13.7848 21.5383 16.9142M20.7188 5.04257c-3.5504-6.28886-12.88753-4.410077-16.44303.0C2.88063 6.77451-.0433281 11.1668 1.38159 16.6571c.89322 3.4417 3.7911 5.6365 6.81584 6.1154M20.7188 5.04257c1.3509 1.89783 3.3111 6.34223 1.6353 10.37273M21.5383 16.9142C21.8737 16.4251 22.1428 15.9235 22.3541 15.4153M8.19743 22.7725C12.1971 23.4683 20.6281 22.971 22.3541 15.4153M14 10.945C13.3836 10.289 12.003 8.63215 11.2034 7.04814 11.1703 6.98257 11.0247 6.98456 10.9937 7.05061 10.5221 8.05496 9.07362 9.92941 8 10.945m3.0333-3.50056C10.9392 9.86549 11 15 12 17" stroke="currentcolor" stroke-linecap="round"/></svg>
</a><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const s=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="Copy";function n(){t.innerHTML="Copied",setTimeout(()=>{t.innerHTML="Copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),n();return}const s=document.createRange();s.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(s);try{document.execCommand("copy"),n()}catch{}o.removeRange(s)}),e.parentNode.appendChild(t)})</script></main></body><script src=https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.0.6/medium-zoom.min.js integrity="sha512-N9IJRoc3LaP3NDoiGkcPa4gG94kapGpaA5Zq9/Dr04uf5TbLFU5q0o8AbRhLKUUlp8QFS2u7S+Yti0U7QtuZvQ==" crossorigin=anonymous referrerpolicy=no-referrer></script><script>const images=Array.from(document.querySelectorAll(".blog-content img"));images.forEach(e=>{mediumZoom(e,{margin:10,scrollOffset:40,container:null,template:null,background:"rgba(0, 0, 0, 0.5)"})})</script><script src=/main.min.6bb26b69159420159c74dc9e097b06a578ed2b68c701466a91a44a9632d851bd0af167a1b30012387b4c512b48ad9ad4d3394e04d77ae38d57e1920fe4ed34fe.js integrity="sha512-a7JraRWUIBWcdNyeCXsGpXjtK2jHAUZqkaRKljLYUb0K8WehswASOHtMUStIrZrU0zlOBNd6441X4ZIP5O00/g==" crossorigin=anonymous defer></script></html>